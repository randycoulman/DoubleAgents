<?xml version="1.0"?><st-source><!-- Name: DoubleAgentsNotice: The MIT LicenseCopyright (c) 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: # DoubleAgentsCreate and use "test doubles" in unit tests.DoubleAgents is licensed under the MIT license.  See the copyright tabin the RB, the 'notice' property of this package, or the License.txtfile on GitHub.DoubleAgents' primary home is the[Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).Check there for the latest version.  It is also on[GitHub](https://github.com/randycoulman/DoubleAgents).DoubleAgents was developed in VW 7.9.1, but is compatible with VW 7.7and later.  If you find any incompatibilities with VW 7.7 or later,let me know (see below for contact information) or file an issue onGitHub.# IntroductionDoubleAgents is a library for creating and working with "test doubles"(think "stunt doubles" in acting) when writing unit tests.  It isoptimized for keeping test code as readable as possible.DoubleAgents supports two kinds of test doubles. See[Mocks Aren't Stubs](http://martinfowler.com/articles/mocksArentStubs.html)for more information.* Stubs are simple objects that don't have any real behavior.  Each  stubbed method does no work and returns a given value.* Mocks are objects that are pre-programmed with a set of  "expectations".  After running the code under test, the mock is  checked to see if all of the expectations have been met.In this library, all test doubles are instances of `DoubleAgent` andcan contain a mixture of stubbed methods and expectations.`DoubleAgent`s can be created directly and used in place of instancesof other classes.  In addition, it is possible to stub or mock methodson existing instances (including class-side methods of existingclasses).  In these latter two cases, all non-doubled methods willcontinue to function like normal.DoubleAgents was designed to support unit testing in the stylerecommended by [Sandi Metz](https://twitter.com/sandimetz) in herexcellent[Practical Object-Oriented Design in Ruby: An Agile Primer](http://www.poodr.info/book/).See her[slides from a talk at Ancient City Ruby](https://speakerdeck.com/skmetz/magic-tricks-of-testing)for a good summary of her advice.# Creating a DoubleAgentThere are three kinds of `DoubleAgent`:* A standalone `DoubleAgent` acts as an instance of its target class.This is the normal usage.  A standalone `DoubleAgent` is created bysending one of the `#expect:*` or `#stub:*` API methods directly to aclass, by sending `#doubleAgent` to the class, or by explicitlycreating the `DoubleAgent`.    AClass expect: #aMessage [...]    AClass stub: #aMessage [...]    AClass doubleAgent    DoubleAgent of: AClass* An in-place instance-side `DoubleAgent` is used for objects that arepart of a more complex object structure where it is difficult toinject a standalone `DoubleAgent` as a dependency.  It allowsselective mocking and stubbing, where only a few methods are doubledand all other methods have their normal behavior.  An in-placeinstance-side `DoubleAgent` is created by sending one of the`#expect:*` or `#stub:*` API methods directly to the instance, bysending `#doubleAgent` to the instance, or by explicitly creating the`DoubleAgent`.    anInstance expect: #aMessage [...]    anInstance stub: #aMessage [..]    anInstance doubleAgent    DoubleAgent around: anInstance* An in-place class-side `DoubleAgent` is similar to an in-placeinstance-side double, but is used for mocking or stubbing class-sidemethods of a class.  Note that doubled methods on classes are globalthroughout the system, so use this facility with care.  For example,attempting to stub something like `Timer class>>after:do:` will hang thedebugger.  An in-place class-side `DoubleAgent` is created by sending`#classSideDouble` to the class, or by explicitly creating the`DoubleAgent`.    aClass classSideDouble    DoubleAgent around: AClass# Stubbing and Mocking MethodsThere is a family of methods for creating method stubs and definingmethod expectations.  These methods can be sent to a `DoubleAgent`, toa class (which automatically creates and returns a `DoubleAgent`), orto an object (which stubs or mocks the method "in place").A method may only be mocked or stubbed if it is understood by theclass or instance being doubled.  This is to provide extra assurancethat the test double uses the same API as the real class.## Return ValuesAll stubbed and mocked methods return a value when they are called.* If the API call doesn't specify a return value, then `self` itself is returned.* If the API call ends with `return: anObject`, then `anObject` is returned from every call to the method.* If the API call ends with `do: aBlock`, then `aBlock` is evaluated  with the arguments passed to the method, and the result is returned.  Note that the arguments are "culled" to the block, so the block  doesn't need to specify the arguments if it doesn't need them.## Stubbing a MethodTo stub a method, use one of the following:* `stub: aMessage`* `stub: aMessage return: anObject`* `stub: aMessage do: aBlock`These methods do nothing but return a value as outlined above.## Disallowing a MessageSometimes, it is desirable to explicitly state that a particularmessage will not be sent to an object.  To disallow a message send,use the following:* `disallow: aMessage`If a disallowed message is sent, a `BurnNotice` is raised.## Defining Expectations for a MethodIn order to verify that a message is sent to an object, use one of thefollowing:* `expect: aMessage`* `expect: aMessage return: anObject`* `expect: aMessage do: aBlock`These methods check that `aMessage` was sent, but do not perform anychecks on the arguments.  They do nothing else except return a valueas outlined above.If the arguments are important, use one of the following:* `expect: aMessage with: anObject`* `expect: aMessage with: anObject with: anotherObject`* `expect: aMessage with: anObject with: anotherObject with: aThirdObject`* `expect: aMessage withArguments: aCollection`* `expect: aMessage with: anObject return: anObject`* `expect: aMessage with: anObject with: anotherObject return: anObject`* `expect: aMessage with: anObject with: anotherObject with: aThirdObject return: anObject`* `expect: aMessage withArguments: aCollection return: anObject`* `expect: aMessage with: anObject do: aBlock`* `expect: aMessage with: anObject with: anotherObject do: aBlock`* `expect: aMessage with: anObject with: anotherObject with: aThirdObject do: aBlock`* `expect: aMessage withArguments: aCollection do: aBlock`The general forms are the `#expect:withArguments:*` methods; theothers are provided as convenient shortcuts.  These methods check that`aMessage` was sent with arguments that are "congruent" to those specified.They do nothing else except return a value as outlined above.Argument congruency is implemented using the `#===` method provided bythe [Threequals](https://github.com/randycoulman/Threequals) package.See that package for more details, but as a summary:* Objects that are `#=` are also `#===`.* A class is `#===` to an object that `#isKindOf:` the class.* A block is `#===` to an object if it evaluates to true when passed  the object.* An interval is `#===` to a number that is between the endpoints of  the interval, including the endpoints.* If Threequals-Regex is loaded, a regular expression is `#===` to a  string that matches it.Using `#===` allows for expectations like the following:```myDouble expect: #with:and:do:         with: (40 to: 42)         with: [:x | x even]         with: BlockClosure```This expectation will be satisfied if the arguments are some numberbetween 40 and 42 inclusive, an even number, and a block.For even more flexible argument checking, use one of the following:* `expect: aMessage where: aBlock`* `expect: aMessage where: aBlock return: anObject`* `expect: aMessage where: aBlock do: returnBlock`These methods check that `aMessage` was sent with arguments thatsatisfy `aBlock`.  `aBlock` must take some or all of the arguments andreturn a Boolean indicating whether the arguments are satisfactory.They do nothing else except return a value as outlined above.## Verifying that Expectations Are MetIf an unexpected message is sent to a `DoubleAgent`, it willimmediately raise a `BurnNotice` exception.  It is necessary to checkthat all expectations are met at the end of a test.  All DoubleAgentsregister with a singleton instance of `Agency`.  `Agency` isresponsible for verifying all of the `DoubleAgent`s and for ensuringthat they clean up after themselves.  If an expectation is not met, a`BurnNotice` exception will be raised.`Agency` provides several options for verification and cleanup.* `Agency class>>tearDown` verifies all registered `DoubleAgent`s and  then ensures that any cleanup actions they need to perform are done.  Only the first `BurnNotice` will be reported.  All cleanup actions  will be performed even if a `BurnNotice` is raised, and even if a  cleanup action raises an exception.  This method should be called  from the `tearDown` of your test class.    If your `tearDown` method  performs other actions that might fail, it is recommended that you  use an `#ensure:` block to guarantee that `Agency class>>tearDown`  is sent in all cases.* `Agency class>>setUp` verifies that the `Agency` was torn down  correctly by the last test that used it.  If not, a `BurnNotice`  will be raised.  This may not help figure out which test failed to  tear down the `Agency`, but will alert you to a problem and ensure  that each test starts out in a clean state.  This method should be  called from the `setUp` of your test class.* If you use SUnitToo, `DoubleAgentTestCase` (in  DoubleAgents-SUnitToo) implements `setUp` and `tearDown` methods  that forward to the `Agency`.  You can have your test class inherit  from `DoubleAgentTestCase` to ensure that the `Agency` is managed  properly.  Make sure that your `setUp` and `tearDown` also send to  `super` in addition to their own actions.  If your `tearDown` method  performs other actions that might fail, it is recommended that you  use an `#ensure:` block to guarantee that the superclass `tearDown`  is sent in all cases.* `Agency class>>verifyAfter: aBlock` wraps `aBlock` with `setUp` and  `tearDown` calls.  This method is handy for a single test that uses  `DoubleAgent`s.  For multiple tests in a class, though, it is better  to use one of the earlier options.* `aBlock verifyAgents` is a handy shortcut for `verifyAfter:`.  You  can wrap the body of your test in a block and send `verifyAgents` to  the block.* `Agency class>>forceReset` ensures that the `Agency` is cleaned up  correctly, but does not perform any verification.  This method  should not be used in normal circumstances, but can be used in a  pinch if your image gets left in a bad state somehow.## Flexible vs StrictBy default, standalone `DoubleAgent`s are "strict".  That is, theyonly allow messages to be sent that have been stubbed or mocked.  Allother message sends raise a `BurnNotice`.  For in-place`DoubleAgent`s, messages that have not been stubbed or mockedimplement their normal behavior.  A "flexible" `DoubleAgent` willallow other messages to be sent; they will simply return `self`.`DoubleAgent` implements `#flexible` and `#strict` to convert betweenthe two.## Ordered SendsBy default, mock expectations are "unordered".  That is, the messagescan be sent to the `DoubleAgent` in any order.  An "ordered"`DoubleAgent` requires the messages to be sent in the specified order.It will raise a `BurnNotice` if any messages are sent out of order.`DoubleAgent` implements `#ordered` and `#unordered` to convertbetween the two.## ConflictsThe same method can be mocked or stubbed repeatedly.  The rule is"last one wins".  That is, if you first stub a method, and then laterset a mock expectation on it, then the method will be a mock that isverified.  Similarly, if you set a mock expectation on a method andthen later stub the same method, then it will be a stub.  Setting amock expectation on a method that is already a mock simply adds thenew expectation to the existing expectations; it means that the methodmust be sent more than once.A common pattern is to stub a method in a test's `setUp`, and then inone or more tests, set a mock expectation to verify that the messageis sent to the object.# Understanding the Code`DoubleAgent` is the central class in this library.  It has subclassesthat implement the three main types of agent: `StandaloneDouble`,`InPlaceInstanceDouble`, and `InPlaceClassDouble`.All `DoubleAgent`s register with the singleton `Agency`, which isresponsible for verifying all mock expectations and cleaning up.When verifying expectations, method arguments are verified by an`ArgumentPolicy` such as `IgnoreArguments`, `ArgumentsEqual`, or`ArgumentsMatch`.Doubled methods are represented by a `MethodDouble`, either`MockMethod` or a `StubMethod`.# AcknowledgementsI stood on the shoulders of several giants when implementing thislibrary.As already mentioned, I was inspired to write this library by tryingto follow [Sandi Metz](https://twitter.com/sandimetz)'s testing advicein[Practical Object-Oriented Design in Ruby: An Agile Primer](http://www.poodr.info/book/).I looked at several other test double libraries for API andimplementation ideas, including:* [Smallmock](http://www.cincomsmalltalk.com/publicRepository/SmallMock.html)* [Flexmock](https://github.com/jimweirich/flexmock)* [JMock](http://jmock.org/)* [RSpec mocks](https://github.com/rspec/rspec-mocks)The in-place double implementations use some clever tricks that wereinspired by the[MethodWrappers](http://www.refactory.com/tools/method-wrappers)project and a couple of blog posts by[Travis Griggs](http://objology.blogspot.com/):* [Superpower Adventures in Lightweight Classing](http://www.cincomsmalltalk.com/userblogs/travis/blogView?showComments=true&entry=3440856756)* [Mutating your Process, for Instance](http://www.cincomsmalltalk.com/userblogs/travis/blogView?showComments=true&entry=3421076502)# ContributingI'm happy to receive bug fixes and improvements to this package.  Ifyou'd like to contribute, please publish your changes as a "branch"(non-integer) version in the Public Store Repository and contact me asoutlined below to let me know.  I will merge your changes back intothe "trunk" as soon as I can review them.# Contact InformationIf you have any questions about DoubleAgents and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1580DbUsername: randyDbVersion: 16DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Protocols-Common' '') #(#any 'Threequals' ''))Namespace: Smalltalk.DoubleAgentsPackageName: DoubleAgentsParcel: #('DoubleAgents')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Protocols-Common' #componentType #package) #(#name 'Threequals' #componentType #package #explicit true))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Protocols-Common' '') #('Threequals' ''))PrintStringCache: (16,randy)Version: 16Date: 8:41:49 AM June 19, 2013 --><time-stamp>From VisualWorks® Personal Use Edition, 7.9.1 of October 18, 2012 on June 19, 2013 at 8:41:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>DoubleAgents</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>DoubleAgents</package></attributes></name-space><class><name>BasicAgent</name><environment>DoubleAgents</environment><super>Protocols.ProtoObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.BasicAgent</class-id><body>BasicAgent, along with its superclass ProtoObject, implement the necessary infrastructure to allow DoubleAgents to survive in the Visualworks infrastructure.ProtoObject should be enough on its own, but it is missing a few required features.  It also implements the #ifNil: family of methods using an older pattern that doesn't play well with Symbol&gt;&gt;value: and #cull:, so those are reimplemented here.The basic idea is that DoubleAgents should have as light an inherited API as possible (hence subclassing from nil instead of Object), but there is a minimal API that must be implemented.</body></comment><class><name>DoubleAgent</name><environment>DoubleAgents</environment><super>DoubleAgents.BasicAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stubs strict mocks ordered announcer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.DoubleAgent</class-id><body>DoubleAgent is the core class of this package.  Any test double created by the framework is an instance of one of DoubleAgent's subclasses.DoubleAgent implements the full mocking and stubbing API (but see also the forwarding extensions on Object).DoubleAgent is (ultimately) a subclass of nil, not Object, so it has as narrow an API as possible.  Necessary Visualworks-required methods are implemented in BasicAgent.  The public API of DoubleAgent uses normaly method names, but any internal methods use an underscore ("_") prefix so that implementation details don't interfere with the APIs being mocked or stubbed.The mocks instance variable is an OrderedCollection, not a Dictionary, in order to support ordered expectations.Subclasses must implement the following messages:	private		_defaultReturnValue		_target		_targetUnderstands:Instance Variables	mocks	&lt;(OrderedCollection of: MockMethod)&gt;	A list of all mock message send expectations; there might be multiple MockMethods for the same selector.	ordered	&lt;Boolean&gt;	True if the expected message sends to the mock must occur in the specified order; false if they can happen in any order.  Defaults to false.	strict	&lt;Boolean&gt;	True if no other messages are allowed except those specified as mocks or stubs; false if other messages can be sent as well.  Has no impact on InPlaceDoubles.  Defaults to true.	stubs	&lt;Dictionary&gt;	Methods that have been stubbed.</body></comment><class><name>InPlaceDouble</name><environment>DoubleAgents</environment><super>DoubleAgents.DoubleAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetInstance </inst-vars><class-inst-vars>registry </class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.InPlaceDouble</class-id><body>Base class for in-place DoubleAgents.  That is, DoubleAgents who are existing instances or classes but have one or more methods mocked or stubbed.  These are sometimes called "partial mocks" or "partial stubs".InPlaceDouble maintains a class-side registry (as a class instance variable) of InPlaceDoubles.  This registry associates Objects and/or Classes with their DoubleAgents.  That way, only one DoubleAgent is created per instance or class.  Then, for each doubled method on the original object, a forwarding method replaces the original method.  The forwarding method looks up the InPlaceDouble and forwards the message and arguments to the double.Instance Variables	targetInstance	&lt;Object&gt;	The object being partially doubled.</body></comment><class><name>InPlaceInstanceDouble</name><environment>DoubleAgents</environment><super>DoubleAgents.InPlaceDouble</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.InPlaceInstanceDouble</class-id><body>An in-place DoubleAgent of an existing Object.InPlaceInstanceDouble works by temporarily replacing the class of the object being doubled with a copy of its original class.  Double methods are then installed into the copy.  On _tearDown, the object's original class is restored.See these blog posts by [Travis Griggs](http://objology.blogspot.com/):* [Superpower Adventures in Lightweight Classing](http://www.cincomsmalltalk.com/userblogs/travis/blogView?showComments=true&amp;entry=3440856756)* [Mutating your Process, for Instance](http://www.cincomsmalltalk.com/userblogs/travis/blogView?showComments=true&amp;entry=3421076502)Instance Variables	originalClass	&lt;Class&gt;	The original class of the instance being doubled.</body></comment><class><name>ArgumentPolicy</name><environment>DoubleAgents</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.ArgumentPolicy</class-id><body>The abstract base class of argument-matching policies for mock expectations.Subclasses must implement the following messages:	verifying		matchesArguments:</body></comment><class><name>ArgumentsMatch</name><environment>DoubleAgents</environment><super>DoubleAgents.ArgumentPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.ArgumentsMatch</class-id><body>An argument-matching policy that requires a message's arguments to satisfy a condition specified by a block.This policy is handy when #= is too strong a condition, but it is still important to verify some property of one or more arguments.The block can take any of the message's arguments (#cull: is used) and must return true if the arguments match and false otherwise.Instance Variables	block	&lt;BlockClosure&gt;	The block that determines whether or not the arguments are satisfactory.</body></comment><class><name>MethodDouble</name><environment>DoubleAgents</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.MethodDouble</class-id><body>The base class for methods that have been mocked or stubbed.  This class implements the basic method invocation/return value facility for doubled methods.Instance Variables	returnBlock	&lt;BlockClosure&gt;	A block that computes the fake return value for the doubled method.</body></comment><class><name>StubMethod</name><environment>DoubleAgents</environment><super>DoubleAgents.MethodDouble</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.StubMethod</class-id><body>A MethodDouble representing a stubbed method.  It adds no additional behavior to MethodDouble, but exists for the communication value of its name.</body></comment><class><name>IgnoreArguments</name><environment>DoubleAgents</environment><super>DoubleAgents.ArgumentPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.IgnoreArguments</class-id><body>An argument-matching policy that accepts any arguments as valid.</body></comment><class><name>StandaloneDouble</name><environment>DoubleAgents</environment><super>DoubleAgents.DoubleAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.StandaloneDouble</class-id><body>A DoubleAgent that stands on its own, completely replacing the object being doubled.Instance Variables	targetClass	&lt;Class&gt;	The class of the object being doubled.</body></comment><class><name>MockMethod</name><environment>DoubleAgents</environment><super>DoubleAgents.MethodDouble</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argumentPolicy met selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.MockMethod</class-id><body>A MethodDouble representing a mocked method.Instance Variables	argumentPolicy	&lt;ArgumentPolicy&gt;	How arguments should be matched.	met	&lt;Boolean&gt;	Has this expectation been met yet?	selector	&lt;Symbol&gt;	The selector of the method being mocked.</body></comment><class><name>BurnNotice</name><environment>DoubleAgents</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.BurnNotice</class-id><body>BurnNotice exceptions are raised when a mock expectation is not met.  Either an unexpected message has been sent, or an expected message was not sent.</body></comment><class><name>InPlaceClassDouble</name><environment>DoubleAgents</environment><super>DoubleAgents.InPlaceDouble</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.InPlaceClassDouble</class-id><body>An in-place DoubleAgent of a class.  Useful for mocking or stubbing a class-side method of an object.Note that doubled methods on classes are global throughout the system, so use this facility with care.  For example, attempting to stub something like Timer class&gt;&gt;after:do: will hang the debugger.InPlaceClassDouble uses the exact same technique as MethodWrappers to replace the doubled method.  The original implementation of each doubled method is cached and then restored on _tearDown.  If the same method is doubled more than once, care is take to remember the original, un-doubled method, and not the most recent double.I could have used MethodWrappers for this, but didn't want to pull in the whole library for the small part of it I need to use.Instance Variables	originalMethods	&lt;Dictionary&gt;	The methods that were doubled.</body></comment><class><name>ArgumentsThreequal</name><environment>DoubleAgents</environment><super>DoubleAgents.ArgumentPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expectedArguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.ArgumentsThreequal</class-id><body>An argument-matching policy that requires all of a message's arguments to be #= to the expected arguments.Instance Variables	expectedArguments	&lt;SequenceableCollection&gt;	The arguments that are expected to be sent with the message.</body></comment><class><name>Agency</name><environment>DoubleAgents</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>agents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DoubleAgents</package></attributes></class><comment><class-id>DoubleAgents.Agency</class-id><body>Agency is a singleton that keeps track of all DoubleAgents that have been created during a test run.  All interaction with the singleton Agency should go through the class-side API.Instance Variables	agents	&lt;(Collection of: DoubleAgent)&gt;	The DoubleAgents that have been created during a test run.</body></comment><shared-variable><name>Current</name><environment>DoubleAgents.Agency</environment><private>false</private><constant>false</constant><category>singleton</category><attributes><package>DoubleAgents</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>DoubleAgents.InPlaceClassDouble</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>DoubleAgents</package></attributes></shared-variable><methods><class-id>DoubleAgents.BasicAgent</class-id> <category>error handling</category><body package="DoubleAgents">subclassResponsibility	^Object subclassResponsibilitySignal		raiseErrorString: #errSubclassResponsibility &lt;&lt; #dialogs				&gt;&gt; 'My subclass should have overridden one of my messages.'</body></methods><methods><class-id>DoubleAgents.BasicAgent</class-id> <category>private</category><body package="DoubleAgents">nilFields	"Store nil into all pointer fields of the receiver."	self class isPointers ifFalse: [^self].	1 to: self basicSize do: [:index | self basicAt: index put: nil].	1 to: self class instSize do: [:index | self instVarAt: index put: nil]</body></methods><methods><class-id>DoubleAgents.BasicAgent</class-id> <category>controlling</category><body package="DoubleAgents">ifNil: nilBlock ifNotNil: notNilBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.	 UndefinedObject redefines this to answer the evaluation of nilBlock, and hence	 since here the receiver is not nil answer the evaluation of notNilBlock."	^notNilBlock cull: self</body><body package="DoubleAgents">ifNotNil: aBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.  Since the receiver is not nil,	 answer aBlock's evaluation.  Passing the receiver to aBlock is handy for idioms	 such as		self toolBarSpec ifNotNil: [:spec | ...].	UndefinedObject reimplements this to not evaluate aBlock."	^aBlock cull: self</body><body package="DoubleAgents">ifNotNil: notNilBlock ifNil: nilBlock	"If the receiver is not nil, answer the evaluation of notNilBlock (with the	 receiver as its argument if it takes one), otherwise answer the evaluation	 of nilBlock.  UndefinedObject redefines this to answer the evaluation of nilBlock,	 and hence since here the receiver is not nil answer the evaluation of notNilBlock."	^notNilBlock cull: self</body></methods><methods><class-id>DoubleAgents.BasicAgent</class-id> <category>accessing</category><body package="DoubleAgents">whileMutableDo: aBlock	aBlock value</body><body package="DoubleAgents">yourself	^self</body></methods><methods><class-id>DoubleAgents.BasicAgent</class-id> <category>comparing</category><body package="DoubleAgents">=== anObject	^self = anObject</body></methods><methods><class-id>DoubleAgents.DoubleAgent</class-id> <category>mocking</category><body package="DoubleAgents">expect: aSelector	"Verify that aSelector is sent to the object with any arguments.	Answer 'self'."	self _expect: aSelector argumentPolicy: IgnoreArguments new</body><body package="DoubleAgents">expect: aSelector do: aBlock	"Verify that aSelector is sent to the object with any arguments.	Answer the result of  evaluating aBlock with the message's arguments.	The arguments are passed to the block with #cull:, so they are optional."	self		_expect: aSelector		argumentPolicy: IgnoreArguments new		do: aBlock</body><body package="DoubleAgents">expect: aSelector return: anObject	"Verify that aSelector is sent to the object with any arguments.	Answer anObject."	self		_expect: aSelector		argumentPolicy: IgnoreArguments new		return: anObject</body><body package="DoubleAgents">expect: aSelector where: aBlock	"Verify that aSelector is sent to the object with arguments that satisfy aBlock.	The arguments are passed to the block with #cull:, so they are optional.	Answer 'self'."	^self _expect: aSelector argumentPolicy: (ArgumentsMatch where: aBlock)</body><body package="DoubleAgents">expect: aSelector where: aBlock do: returnBlock	"Verify that aSelector is sent to the object with arguments that satisfy aBlock.	Answer the result of  evaluating returnBlock with the message's arguments.	The arguments are passed to both blocks with #cull:, so they are optional."	^self		_expect: aSelector		argumentPolicy: (ArgumentsMatch where: aBlock)		do: returnBlock</body><body package="DoubleAgents">expect: aSelector where: aBlock return: anObject	"Verify that aSelector is sent to the object with arguments that satisfy aBlock.	The arguments are passed to the block with #cull:, so they are optional.	Answer anObject."	^self		_expect: aSelector		argumentPolicy: (ArgumentsMatch where: aBlock)		return: anObject</body><body package="DoubleAgents">expect: aSelector with: anObject	"Verify that aSelector is sent to the object with an argument that is #= to anObject.	Answer 'self'."	self expect: aSelector withArguments: (Array with: anObject)</body><body package="DoubleAgents">expect: aSelector with: anObject do: aBlock	"Verify that aSelector is sent to the object with an argument that is #= to anObject.	Answer the result of  evaluating aBlock with the message's arguments.	The arguments are passed to the block with #cull:, so they are optional."	self		expect: aSelector		withArguments: (Array with: anObject)		do: aBlock</body><body package="DoubleAgents">expect: aSelector with: anObject return: returnObject	"Verify that aSelector is sent to the object with an argument that is #= to anObject.	Answer anObject."	self		expect: aSelector		withArguments: (Array with: anObject)		return: returnObject</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2	"Verify that aSelector is sent to the object with arguments that are #= to anObject1 and anObject2.	Answer 'self'."	self expect: aSelector		withArguments: (Array with: anObject1 with: anObject2)</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 do: aBlock	"Verify that aSelector is sent to the object with arguments that are #= to anObject1 and anObject2.	Answer the result of  evaluating aBlock with the message's arguments.	The arguments are passed to the block with #cull:, so they are optional."	self		expect: aSelector		withArguments: (Array with: anObject1 with: anObject2)		do: aBlock</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 return: returnObject	"Verify that aSelector is sent to the object with arguments that are #= to anObject1 and anObject2.	Answer anObject."	self		expect: aSelector		withArguments: (Array with: anObject1 with: anObject2)		return: returnObject</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 with: anObject3	"Verify that aSelector is sent to the object with arguments that are #= to anObject1, anObject2, and anObject3.	Answer 'self'."	self expect: aSelector		withArguments: (Array with: anObject1 with: anObject2 with: anObject3)</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 with: anObject3 do: aBlock	"Verify that aSelector is sent to the object with arguments that are #= to anObject1, anObject2, and anObject3.	Answer the result of  evaluating aBlock with the message's arguments.	The arguments are passed to the block with #cull:, so they are optional."	self		expect: aSelector		withArguments: (Array with: anObject1 with: anObject2 with: anObject3)		do: aBlock</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 with: anObject3 return: returnObject	"Verify that aSelector is sent to the object with arguments that are #= to anObject1, anObject2, and anObject3.	Answer anObject."	self		expect: aSelector		withArguments: (Array with: anObject1 with: anObject2 with: anObject3)		return: returnObject</body><body package="DoubleAgents">expect: aSelector withArguments: aCollection	"Verify that aSelector is sent to the object with arguments that are #= to aCollection.	Answer 'self'."	self _expect: aSelector argumentPolicy: (ArgumentsThreequal to: aCollection)</body><body package="DoubleAgents">expect: aSelector withArguments: aCollection do: aBlock	"Verify that aSelector is sent to the object with arguments that are #= to aCollection.	Answer the result of  evaluating aBlock with the message's arguments.	The arguments are passed to the block with #cull:, so they are optional."	self		_expect: aSelector		argumentPolicy: (ArgumentsThreequal to: aCollection)		do: aBlock</body><body package="DoubleAgents">expect: aSelector withArguments: aCollection return: anObject	"Verify that aSelector is sent to the object with arguments that are #= to aCollection.	Answer anObject."	self		_expect: aSelector		argumentPolicy: (ArgumentsThreequal to: aCollection)		return: anObject</body></methods><methods><class-id>DoubleAgents.DoubleAgent</class-id> <category>private</category><body package="DoubleAgents">_addForwardingStubsForAnnouncerAPI	self		stub: #when:do:			do: [:announcement :block | announcer when: announcement do: block];		stub: #when:do:for:			do: [:announcement :block :subscriber | announcer when: announcement do: block for: subscriber];		stub: #when:send:to:			do: [:announcement :message :receiver | announcer when: announcement send: message to: receiver];		stub: #announce: do: [:announcement | announcer announce: announcement];		stub: #unsubscribe: do: [:subscriber | announcer unsubscribe: subscriber];		stub: #unsubscribe:from:			do: [:subscriber :announcement | announcer unsubscribe: subscriber from: announcement];		stub: #subscriptionRegistry:			do: [:registry | announcer subscriptionRegistry: registry];		stub: #subscriptionRegistry do: [announcer subscriptionRegistry];		stub: #subscriptionRegistryOrNil do: [announcer subscriptionRegistryOrNil]</body><body package="DoubleAgents">_anyMockMatching: aMessage ifNone: aBlock	^mocks detect: [:each | each matchesMessage: aMessage] ifNone: aBlock</body><body package="DoubleAgents">_cannotDouble: aSelector	| selectorString |	^Object messageNotUnderstoodSignal		raiseWith: (Message selector: aSelector)		errorString: 			[selectorString := [aSelector printString] on: Error						do: [:ex | ex return: '** unprintable selector **'].			'&lt;1p&gt; does not understand: &lt;2s&gt;' expandMacrosWith: self _target				with: selectorString]</body><body package="DoubleAgents">_defaultReturnValue	"The value to be returned if no other return value is specified.  This should be the object that is logically 'self' in the context of this DoubleAgent."	^self subclassResponsibility</body><body package="DoubleAgents">_doublesSelector: aSelector	^(stubs includesKey: aSelector)		or: [mocks anySatisfy: [:each | each isForSelector: aSelector]]</body><body package="DoubleAgents">_expect: aSelector argumentPolicy: anArgumentPolicy	self		_expect: aSelector		argumentPolicy: anArgumentPolicy		return: self _defaultReturnValue</body><body package="DoubleAgents">_expect: aSelector argumentPolicy: anArgumentPolicy do: aBlock	| expectation |	self _failUnlessTargetUnderstands: aSelector.	expectation := MockMethod				selector: aSelector				argumentPolicy: anArgumentPolicy				returnBlock: aBlock.	mocks addLast: expectation</body><body package="DoubleAgents">_expect: aSelector argumentPolicy: anArgumentPolicy return: anObject	self		_expect: aSelector		argumentPolicy: anArgumentPolicy		do: [anObject]</body><body package="DoubleAgents">_failUnlessTargetUnderstands: aSelector	(self _targetUnderstands: aSelector)		ifFalse: [self _cannotDouble: aSelector]</body><body package="DoubleAgents">_methodMatching: aMessage ifFound: aBlock	| method |	method := self _mockMatching: aMessage				ifNone: [self _stubMatching: aMessage ifNone: [^self]].	aBlock value: method</body><body package="DoubleAgents">_mockMatching: aMessage ifNone: aBlock	^ordered		ifTrue: [self _orderedMockMatching: aMessage ifNone: aBlock]		ifFalse: [self _anyMockMatching: aMessage ifNone: aBlock]</body><body package="DoubleAgents">_orderedMockMatching: aMessage ifNone: aBlock	| candidate |	candidate := mocks detect: [:each | each isMet not] ifNone: [^aBlock value].	^(candidate matchesMessage: aMessage)		ifTrue: [candidate]		ifFalse: [aBlock value]</body><body package="DoubleAgents">_removeAllMocksForSelector: aSelector	mocks := mocks reject: [:each | each isForSelector: aSelector]</body><body package="DoubleAgents">_shouldRespondToUnknownSelector: aSelector	^strict not and: [self _targetUnderstands: aSelector]</body><body package="DoubleAgents">_stubMatching: aMessage ifNone: aBlock	^stubs at: aMessage selector ifAbsent: aBlock</body><body package="DoubleAgents">_target	"The target object of this DoubleAgent.  Might be an instance or a class."	^self subclassResponsibility</body><body package="DoubleAgents">_targetUnderstands: aSelector	"Answer true if the target understands aSelector; false otherwise."	^self subclassResponsibility</body><body package="DoubleAgents">_verify	mocks do: #verify</body></methods><methods><class-id>DoubleAgents.DoubleAgent</class-id> <category>stubbing</category><body package="DoubleAgents">disallow: aSelector	"Ensure that aSelector is not sent.  Raises BurnNotice if it is."	self stub: aSelector		do: 			[BurnNotice raiseErrorString: ('Disallowed method &lt;1p&gt; was sent'						expandMacrosWith: aSelector)]</body><body package="DoubleAgents">stub: aSelector	"Stub a method to do nothing but answer 'self'."	self stub: aSelector return: self _defaultReturnValue</body><body package="DoubleAgents">stub: aSelector do: aBlock	"Stub a method to evaluate aBlock with any provided arguments every time it is sent.	The arguments are passed to the block with #cull:, so they are optional."	self _failUnlessTargetUnderstands: aSelector.	self _removeAllMocksForSelector: aSelector.	stubs at: aSelector put: (StubMethod returnBlock: aBlock)</body><body package="DoubleAgents">stub: aSelector return: anObject	"Stub a method to always answer anObject."	self stub: aSelector do: [anObject]</body></methods><methods><class-id>DoubleAgents.DoubleAgent</class-id> <category>initialize-release</category><body package="DoubleAgents">_initialize	stubs := IdentityDictionary new.	mocks := OrderedCollection new.	strict := true.	ordered := false.	Agency register: self</body><body package="DoubleAgents">_tearDown	"Do nothing by default"</body><body package="DoubleAgents">beAnnouncer	announcer ifNotNil: [^self].	announcer := Announcer new.	self _addForwardingStubsForAnnouncerAPI</body><body package="DoubleAgents">flexible	"Allow other messages to be sent to this DoubleAgent that were not explicitly mocked or stubbed.	These additional methods will do nothing but return 'self'."	strict := false</body><body package="DoubleAgents">ordered	"Require expected messages to be sent in the specified order."	ordered := true</body><body package="DoubleAgents">strict	"Only specified mocked or stubbed messages may be sent to this DoubleAgent.	All other messages will result in a BurnNotice being raised.	This is the default.	Strict mode does not apply to in-place doubles; in those cases, the original methods will be invoked."	strict := true</body><body package="DoubleAgents">unordered	"Allow any expected messages to be sent in any order.  This is the default."	ordered := false</body></methods><methods><class-id>DoubleAgents.DoubleAgent</class-id> <category>class membership</category><body package="DoubleAgents">respondsTo: aSelector	"We respond to anything that we've mocked or stubbed."	^(self _doublesSelector: aSelector) or: 			[(self _shouldRespondToUnknownSelector: aSelector)				or: [super respondsTo: aSelector]]</body></methods><methods><class-id>DoubleAgents.DoubleAgent</class-id> <category>error handling</category><body package="DoubleAgents">_unexpectedSend: aMessage	^BurnNotice raiseErrorString: 'Unexpected send of ' , aMessage printString</body><body package="DoubleAgents">doesNotUnderstand: aMessage	"This is the core of mocking and stubbing.  Look up any expected or stubbed method and invoke it.	If none, then either return self (for non-strict mode), raise a BurnNotice, or call super for a true MessageNotUnderstood error."	self _methodMatching: aMessage		ifFound: [:method | ^method invokeWithArguments: aMessage arguments].	(self _shouldRespondToUnknownSelector: aMessage selector)		ifTrue: [^self _defaultReturnValue].	(self respondsTo: aMessage selector)		ifTrue: [^self _unexpectedSend: aMessage].	^super doesNotUnderstand: aMessage</body></methods><methods><class-id>DoubleAgents.DoubleAgent class</class-id> <category>instance creation</category><body package="DoubleAgents">around: anObject	^anObject isBehavior		ifTrue: [InPlaceClassDouble of: anObject]		ifFalse: [InPlaceInstanceDouble of: anObject]</body><body package="DoubleAgents">new	^super new _initialize</body><body package="DoubleAgents">of: aClass	^StandaloneDouble of: aClass</body></methods><methods><class-id>DoubleAgents.InPlaceDouble</class-id> <category>private</category><body package="DoubleAgents">_defaultReturnValue	"The value to be returned if no other return value is specified.  This should be the object that is logically 'self' in the context of this DoubleAgent."	^self _target</body><body package="DoubleAgents">_expect: aSelector argumentPolicy: anArgumentPolicy do: aBlock	self _installForwardingMethodIfNeeded: aSelector		after: [super _expect: aSelector argumentPolicy: anArgumentPolicy do: aBlock]</body><body package="DoubleAgents">_installForwardingMethod: aSelector	"Compile a method that forwards to the DoubleAgent.  Do this in a way that doesn't register changes in any packages.	Use the full name of our class, because targetInstance's environment may not import DoubleAgents."	| methodText methodNode |	methodText := '&lt;1s&gt;&lt;n&gt;^(&lt;2s&gt; lookup: self) &lt;1s&gt;'				expandMacrosWith: (self _methodHeaderForSelector: aSelector)				with: self class fullName.	methodNode := targetInstance class compilerClass new				compile: methodText				in: targetInstance class				notifying: nil				ifFail: [].	targetInstance class replaceMethodAt: aSelector		withMethod: methodNode generate</body><body package="DoubleAgents">_installForwardingMethodIfNeeded: aSelector after: aBlock	| needsForwardingMethod |	needsForwardingMethod := (self _doublesSelector: aSelector) not.	aBlock value.	needsForwardingMethod ifTrue: [self _installForwardingMethod: aSelector]</body><body package="DoubleAgents">_methodHeaderForSelector: aSelector	"Construct a method header for aSelector, using placeholder argument names."	| argNames ws |	aSelector numArgs isZero ifTrue: [^aSelector].	argNames := (1 to: aSelector numArgs)				collect: [:i | 'arg' , i printString].	ws := String new writeStream.	aSelector keywords with: argNames		do: 			[:keyword :argument |			ws				nextPutAll: keyword;				space;				nextPutAll: argument;				space].	^ws contents</body><body package="DoubleAgents">_target	"The target object of this DoubleAgent.  Might be an instance or a class."	^targetInstance</body><body package="DoubleAgents">_targetUnderstands: aSelector	"Answer true if the target understands aSelector; false otherwise."	^targetInstance class canUnderstand: aSelector</body><body package="DoubleAgents">_tearDown	self class unregister: self.	super _tearDown</body></methods><methods><class-id>DoubleAgents.InPlaceDouble</class-id> <category>initialize-release</category><body package="DoubleAgents">_initializeTargetInstance: anObject	targetInstance := anObject.	self class register: self</body></methods><methods><class-id>DoubleAgents.InPlaceDouble</class-id> <category>stubbing</category><body package="DoubleAgents">stub: aSelector do: aBlock	self _installForwardingMethodIfNeeded: aSelector		after: [super stub: aSelector do: aBlock]</body></methods><methods><class-id>DoubleAgents.InPlaceDouble class</class-id> <category>registry</category><body package="DoubleAgents">lookup: anObject	^self registry at: anObject ifAbsent: [nil]</body><body package="DoubleAgents">register: anInstanceDouble	self registry at: anInstanceDouble _target put: anInstanceDouble</body><body package="DoubleAgents">registry	^registry ifNil: [registry := IdentityDictionary new]</body><body package="DoubleAgents">resetRegistry	"self resetRegistry"	registry := nil</body><body package="DoubleAgents">unregister: anInstanceDouble	self registry removeKey: anInstanceDouble _target ifAbsent: []</body></methods><methods><class-id>DoubleAgents.InPlaceDouble class</class-id> <category>instance creation</category><body package="DoubleAgents">of: anObject	^(self lookup: anObject)		ifNil: [self new _initializeTargetInstance: anObject]</body></methods><methods><class-id>DoubleAgents.InPlaceInstanceDouble</class-id> <category>initialize-release</category><body package="DoubleAgents">_initializeTargetInstance: anObject	anObject isImmutable		ifTrue: 			[^BurnNotice raiseErrorString: 'Attempting to double an immutable object'].	super _initializeTargetInstance: anObject.	originalClass := targetInstance class.	self _installTemporarySubclass</body><body package="DoubleAgents">_installTemporarySubclass	| newClass |	newClass := originalClass copy.	newClass setName: (originalClass name , '_DoubleAgentTempCopy') asSymbol.	newClass setOrganization: originalClass organization copy.	targetInstance changeClassTo: newClass</body><body package="DoubleAgents">_removeTemporarySubclass	targetInstance ifNil: [^self].	targetInstance changeClassTo: originalClass</body></methods><methods><class-id>DoubleAgents.InPlaceInstanceDouble</class-id> <category>private</category><body package="DoubleAgents">_tearDown	self _removeTemporarySubclass.	super _tearDown</body></methods><methods><class-id>DoubleAgents.ArgumentPolicy</class-id> <category>verifying</category><body package="DoubleAgents">matchesArguments: aCollection	^self subclassResponsibility</body></methods><methods><class-id>DoubleAgents.ArgumentsMatch</class-id> <category>initialize-release</category><body package="DoubleAgents">initializeBlock: aBlock	block := aBlock</body></methods><methods><class-id>DoubleAgents.ArgumentsMatch</class-id> <category>verifying</category><body package="DoubleAgents">matchesArguments: aCollection	^block cullWithArguments: aCollection</body></methods><methods><class-id>DoubleAgents.ArgumentsMatch class</class-id> <category>instance creation</category><body package="DoubleAgents">where: aBlock	^self new initializeBlock: aBlock</body></methods><methods><class-id>DoubleAgents.MethodDouble</class-id> <category>initialize-release</category><body package="DoubleAgents">initializeReturnBlock: aBlock	returnBlock := aBlock</body></methods><methods><class-id>DoubleAgents.MethodDouble</class-id> <category>calling</category><body package="DoubleAgents">invokeWithArguments: aCollection	^returnBlock cullWithArguments: aCollection</body></methods><methods><class-id>DoubleAgents.MethodDouble class</class-id> <category>instance creation</category><body package="DoubleAgents">returnBlock: aBlock	^self new initializeReturnBlock: aBlock</body></methods><methods><class-id>DoubleAgents.IgnoreArguments</class-id> <category>verifying</category><body package="DoubleAgents">matchesArguments: aCollection	^true</body></methods><methods><class-id>DoubleAgents.StandaloneDouble</class-id> <category>initialize-release</category><body package="DoubleAgents">_initializeTargetClass: aClass	targetClass := aClass</body></methods><methods><class-id>DoubleAgents.StandaloneDouble</class-id> <category>private</category><body package="DoubleAgents">_defaultReturnValue	"The value to be returned if no other return value is specified.  This should be the object that is logically 'self' in the context of this DoubleAgent."	^self</body><body package="DoubleAgents">_target	"The target object of this DoubleAgent.  Might be an instance or a class."	^targetClass</body><body package="DoubleAgents">_targetUnderstands: aSelector	"Answer true if the target understands aSelector; false otherwise."	^targetClass canUnderstand: aSelector</body></methods><methods><class-id>DoubleAgents.StandaloneDouble class</class-id> <category>instance creation</category><body package="DoubleAgents">of: aClass	^self new _initializeTargetClass: aClass</body></methods><methods><class-id>DoubleAgents.MockMethod</class-id> <category>testing</category><body package="DoubleAgents">isForSelector: aSelector	^selector == aSelector</body><body package="DoubleAgents">isMet	^met</body><body package="DoubleAgents">matchesMessage: aMessage	"If we've already been met, we don't match any other messages."	^met not and: 			[selector == aMessage selector				and: [argumentPolicy matchesArguments: aMessage arguments]]</body></methods><methods><class-id>DoubleAgents.MockMethod</class-id> <category>verifying</category><body package="DoubleAgents">missingExpectedSend	^BurnNotice raiseErrorString: 'Missing send of ' , selector printString</body><body package="DoubleAgents">verify	met ifFalse: [^self missingExpectedSend]</body></methods><methods><class-id>DoubleAgents.MockMethod</class-id> <category>calling</category><body package="DoubleAgents">invokeWithArguments: aCollection	met := true.	^super invokeWithArguments: aCollection</body></methods><methods><class-id>DoubleAgents.MockMethod</class-id> <category>initialize-release</category><body package="DoubleAgents">initializeSelector: aSymbol argumentPolicy: anArgumentPolicy	selector := aSymbol.	argumentPolicy := anArgumentPolicy.	met := false</body></methods><methods><class-id>DoubleAgents.MockMethod class</class-id> <category>instance creation</category><body package="DoubleAgents">selector: aSymbol argumentPolicy: anArgumentPolicy returnBlock: aBlock	^(self returnBlock: aBlock) initializeSelector: aSymbol		argumentPolicy: anArgumentPolicy</body></methods><methods><class-id>DoubleAgents.InPlaceClassDouble</class-id> <category>private</category><body package="DoubleAgents">_cacheOriginalMethod: aSelector	"Only cache the method if it wasn't already cached;  otherwise, we'd lose the original implementation of the method."	(originalMethods includesKey: aSelector) ifTrue: [^self].	originalMethods at: aSelector		put: (targetInstance class compiledMethodAt: aSelector ifAbsent: [nil])</body><body package="DoubleAgents">_installForwardingMethod: aSelector	self _cacheOriginalMethod: aSelector.	super _installForwardingMethod: aSelector</body></methods><methods><class-id>DoubleAgents.InPlaceClassDouble</class-id> <category>initialize-release</category><body package="DoubleAgents">_initializeTargetInstance: aClass	super _initializeTargetInstance: aClass.	originalMethods := IdentityDictionary new</body><body package="DoubleAgents">_restoreOriginalMethods	"We take care to use an API that doesn't touch ChangeSet.  We don't want mocking and stubbing to show up as changes to the package being tested."	originalMethods keysAndValuesDo: 			[:selector :method |			method				ifNil: [targetInstance class simplyRemoveSelector: selector]				ifNotNil: [targetInstance class replaceMethodAt: selector withMethod: method]]</body><body package="DoubleAgents">_tearDown	self _restoreOriginalMethods.	super _tearDown</body></methods><methods><class-id>DoubleAgents.ArgumentsThreequal</class-id> <category>initialize-release</category><body package="DoubleAgents">initializeExpectedArguments: aCollection	expectedArguments := aCollection</body></methods><methods><class-id>DoubleAgents.ArgumentsThreequal</class-id> <category>verifying</category><body package="DoubleAgents">matchesArguments: aCollection	expectedArguments with: aCollection		do: [:expected :actual | expected === actual ifFalse: [^false]].	^true</body></methods><methods><class-id>DoubleAgents.ArgumentsThreequal class</class-id> <category>instance creation</category><body package="DoubleAgents">to: aCollection	^self new initializeExpectedArguments: aCollection</body></methods><methods><class-id>DoubleAgents.Agency</class-id> <category>testing</category><body package="DoubleAgents">includes: aDoubleAgent	^agents includes: aDoubleAgent</body><body package="DoubleAgents">isEmpty	^agents isEmpty</body></methods><methods><class-id>DoubleAgents.Agency</class-id> <category>initialize-release</category><body package="DoubleAgents">initialize	super initialize.	agents := OrderedCollection new</body><body package="DoubleAgents">tearDownAgents	"Tear down all registered agents, being careful to continue tearing all of the agents down even if an exception occurs.	The first raised exception is the one reported."	| firstError |	firstError := nil.	agents do: 			[:each |			[each _tearDown] on: Error do: [:ex | firstError ifNil: [firstError := ex]]].	firstError		ifNotNil: 			[| newException |			newException := firstError copyForReraise.			firstError willProceed				ifTrue: [newException raiseRequest]				ifFalse: [newException raise]]</body><body package="DoubleAgents">verifyAgents	agents do: #_verify</body></methods><methods><class-id>DoubleAgents.Agency</class-id> <category>accessing</category><body package="DoubleAgents">register: aDoubleAgent	agents add: aDoubleAgent</body></methods><methods><class-id>DoubleAgents.Agency class</class-id> <category>instance creation</category><body package="DoubleAgents">new	^super new initialize</body></methods><methods><class-id>DoubleAgents.Agency class</class-id> <category>lifecycle</category><body package="DoubleAgents">forceReset	"Cleans up all registered agents without verifying them.  This should only be used to clean up after a test failed to send #tearDown."	"self forceReset"	[Current ifNotNil: #tearDownAgents] ensure: [Current := nil]</body><body package="DoubleAgents">setUp	"Intended to be called as part of test setup.  Verifies that the agency starts in a  clean state; otherwise, raises a BurnNotice."	(Current isNil or: [Current isEmpty]) ifTrue: [^self].	BurnNotice raiseErrorString: 'Agency still has registered agents'</body><body package="DoubleAgents">tearDown	"Intended to be called as part of test tearDown.  Verifies all mock expectations and then cleans up all registered DoubleAgents."	[Current ifNotNil: #verifyAgents] ensure: [self forceReset]</body><body package="DoubleAgents">verifyAfter: aBlock	"Wrap aBlock in Agency setUp/tearDown calls.  Handy for a single test case that uses a DoubleAgent.	See also BlockClosure&gt;&gt;verifyAgents"	self setUp.	aBlock ensure: [self tearDown]</body></methods><methods><class-id>DoubleAgents.Agency class</class-id> <category>accessing</category><body package="DoubleAgents">current	^Current ifNil: [Current := self new]</body><body package="DoubleAgents">register: aDoubleAgent	^self current register: aDoubleAgent</body></methods><methods><class-id>DoubleAgents.Agency class</class-id> <category>testing</category><body package="DoubleAgents">includes: aDoubleAgent	^self current includes: aDoubleAgent</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="DoubleAgents">verifyAgents	"Evaluate the receiver in the context of Agency setUp/tearDown.  Handy for a single test case that uses DoubleAgents."	^Agency verifyAfter: self</body></methods><methods><class-id>Core.Object class</class-id> <category>double agents</category><body package="DoubleAgents">classSideDouble	"Create an in-place DoubleAgent that can mock or stub selected class-side methods of this class."	^DoubleAgent around: self</body><body package="DoubleAgents">doubleAgent	"Create a DoubleAgent that acts like an instance of this class."	^DoubleAgent of: self</body></methods><methods><class-id>Core.Object</class-id> <category>double agents</category><body package="DoubleAgents">disallow: aSelector	"Convenience method for creating a DoubleAgent and disallowing a method."	^(self doubleAgent)		disallow: aSelector;		yourself</body><body package="DoubleAgents">doubleAgent	"Create an in-place DoubleAgent that can mock or stub selected methods of this instance."	^DoubleAgent around: self</body><body package="DoubleAgents">expect: aSelector	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector;		yourself</body><body package="DoubleAgents">expect: aSelector do: aBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector do: aBlock;		yourself</body><body package="DoubleAgents">expect: aSelector return: anObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector return: anObject;		yourself</body><body package="DoubleAgents">expect: aSelector where: aBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector where: aBlock;		yourself</body><body package="DoubleAgents">expect: aSelector where: aBlock do: returnBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector where: aBlock do: returnBlock;		yourself</body><body package="DoubleAgents">expect: aSelector where: aBlock return: anObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector where: aBlock return: anObject;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector with: anObject;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject do: aBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector with: anObject do: aBlock;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject return: returnObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector with: anObject return: returnObject;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector with: anObject1 with: anObject2;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 do: aBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector			with: anObject1			with: anObject2			do: aBlock;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 return: returnObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector			with: anObject1			with: anObject2			return: returnObject;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 with: anObject3	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector			with: anObject1			with: anObject2			with: anObject3;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 with: anObject3 do: aBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector			with: anObject1			with: anObject2			with: anObject3			do: aBlock;		yourself</body><body package="DoubleAgents">expect: aSelector with: anObject1 with: anObject2 with: anObject3 return: returnObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector			with: anObject1			with: anObject2			with: anObject3			return: returnObject;		yourself</body><body package="DoubleAgents">expect: aSelector withArguments: aCollection	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector withArguments: aCollection;		yourself</body><body package="DoubleAgents">expect: aSelector withArguments: aCollection do: aBlock	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector withArguments: aCollection do: aBlock;		yourself</body><body package="DoubleAgents">expect: aSelector withArguments: aCollection return: anObject	"Convenience method for creating a DoubleAgent and setting a method expectation."	^(self doubleAgent)		expect: aSelector withArguments: aCollection return: anObject;		yourself</body><body package="DoubleAgents">stub: aSelector	"Convenience method for creating a DoubleAgent and stubbing a method."	^(self doubleAgent)		stub: aSelector;		yourself</body><body package="DoubleAgents">stub: aSelector do: aBlock	"Convenience method for creating a DoubleAgent and stubbing a method."	^(self doubleAgent)		stub: aSelector do: aBlock;		yourself</body><body package="DoubleAgents">stub: aSelector return: anObject	"Convenience method for creating a DoubleAgent and stubbing a method."	^(self doubleAgent)		stub: aSelector return: anObject;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProtoObject</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>